<!DOCTYPE html>
<html>
<meta charset="utf-8">
<title>Next Train: Paddington to Tilehurst</title>

<!-- 
    CURRENT IMPLEMENTATION: Client-Side Dynamic HTML Generation
    
    This is a Single Page Application (SPA) approach where:
    1. The HTML provides only the basic structure and styling
    2. All train data fetching and display happens via JavaScript
    3. The page dynamically updates without full page reloads
    4. Real-time countdown timer runs in the browser
    5. Smart refresh intervals based on how close the train is
    
    ARCHITECTURE:
    - Static HTML container with minimal content
    - JavaScript fetches data from /api/next-train/PAD/TLH endpoint
    - DOM manipulation updates the display with fresh train data
    - setInterval() runs countdown timer every second
    - setTimeout() schedules next data refresh based on departure proximity
-->

<head>
    <link rel="stylesheet" href="/styles.css">
</head>

<body>

    <main>
        <!-- Static header text - never changes -->
        <div class="text-header margin-bottom-small">Next train
            from Paddington to Tilehurst departs at</div>

        <!-- Navigation links -->
        <div class="margin-bottom text-right">
            <a href="#" onclick="showServiceBrowser()" class="link">
                Browse all services →
            </a>
        </div>

        <!-- Dynamic content container - populated by JavaScript -->
        <div id="train-display">
            <div>Loading departure information...</div>
        </div>

        <!-- Platform chart container -->
        <div id="chart-container" class="chart-container">
            <div id="chart-loading" class="chart-loading">
                Loading platform history...
            </div>
            <div id="chart-content" class="chart-content"></div>
        </div>
    </main>


    <script>
        // Global variable to track refresh timer
        let refreshTimer = null;

        // Auto-start train data fetch 
        getNextTrain();

        // Function to get the next train data from the server API endpoint
        async function getNextTrain() {
            const display = document.getElementById('train-display');

            try {
                // Fetch train data from the server API endpoint
                // This makes an HTTP request to the Express server running on port 3000
                const response = await fetch('/api/next-train/PAD/TLH');

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                // Parse the JSON response from the server
                const data = await response.json();

                // Check if we got valid departure data with service information
                if (data.departure && data.departure.service) {
                    const nextTrain = data.departure;
                    const service = nextTrain.service;

                    // Choose the time to display: expected if provided and not "On time", otherwise scheduled
                    const departTime = service.etd && service.etd !== 'On time' ? service.etd : service.std;

                    // Build simplified display showing the exact departure time (no countdown)
                    display.innerHTML = `
                            <div class="text-large">${departTime || '--:--'}</div>
                            ${service.platform ? `<div class="text-platform">Platform: ${service.platform}</div>` : ''}
                            ${service.isCancelled ? '<div class="status-cancelled">CANCELLED</div>' : ''}
                            ${service.delayReason ? `<div class="status-delay-reason">Delay reason: ${service.delayReason}</div>` : ''}
                            <div class="margin-bottom-large">
                                <a href="#" onclick="viewServiceHistory('${getCurrentDayOfWeek()}', '${service.std}', '${nextTrain.crs || 'TLH'}')" class="link-large">
                                    View historical data for this service →
                                </a>
                            </div>
                        `;

                    // Schedule next refresh based on how close the departure is
                    scheduleNextRefresh(departTime);

                    // Load platform chart for this service
                    loadPlatformChart();
                } else {
                    // No trains found - show appropriate message
                    display.innerHTML = `
                        <div class="text-no-trains">
                            No trains found.<br>
                            <span class="text-no-trains-subtitle">Trying again in one hour.</span>
                        </div>
                    `;
                    // Schedule a refresh in 1 hour when no trains are found
                    scheduleNextRefresh(null, 60 * 60 * 1000);

                    // Hide chart when no trains found
                    document.getElementById('chart-container').style.display = 'none';
                }

            } catch (error) {
                // Error handling: Show error message if API call fails
                console.error('Error fetching train data:', error);
                display.innerHTML = `
          Failed to fetch train data: ${error.message}
          Make sure your server is running on port 3000.
        `;
                // Schedule a refresh in 30 seconds on error
                scheduleNextRefresh(null, 30 * 1000);

                // Hide chart on error
                document.getElementById('chart-container').style.display = 'none';
            }
        }

        // Function to load platform chart for the current service
        async function loadPlatformChart() {
            const chartContainer = document.getElementById('chart-container');
            const chartLoading = document.getElementById('chart-loading');
            const chartContent = document.getElementById('chart-content');

            try {
                // Show chart container and loading state
                chartContainer.style.display = 'block';
                chartLoading.style.display = 'block';
                chartContent.style.display = 'none';

                // Fetch the SVG chart from the server
                const response = await fetch('/api/next-train-chart/PAD/TLH');

                if (!response.ok) {
                    throw new Error(`Chart request failed: ${response.status}`);
                }

                // Get the SVG content
                const svgContent = await response.text();

                // Display the chart with animation
                chartContent.innerHTML = svgContent;
                chartLoading.style.display = 'none';
                chartContent.classList.add('chart-animate');

                // Trigger animation
                setTimeout(() => {
                    chartContent.classList.add('visible');
                }, 100);

            } catch (error) {
                console.error('Error loading platform chart:', error);
                chartLoading.innerHTML = 'Unable to load platform history';
                chartLoading.classList.add('message-loading');
            }
        }

        // Function to schedule the next refresh based on departure time proximity
        function scheduleNextRefresh(departTime, fixedInterval = null) {
            // Clear any existing timer
            if (refreshTimer) {
                clearTimeout(refreshTimer);
                refreshTimer = null;
            }

            // If a fixed interval is provided (for errors or no trains), use that
            if (fixedInterval) {
                refreshTimer = setTimeout(getNextTrain, fixedInterval);
                const scheduledAt = new Date(Date.now() + fixedInterval);
                console.log(`Next refresh at ${scheduledAt.toLocaleTimeString()} (in ${Math.round(fixedInterval / 1000)}s)`);
                return;
            }

            // If no departure time, schedule a refresh in 1 hour
            if (!departTime || departTime === '--:--') {
                const interval = 60 * 60 * 1000;
                refreshTimer = setTimeout(getNextTrain, interval);
                const scheduledAt = new Date(Date.now() + interval);
                console.log(`Next refresh at ${scheduledAt.toLocaleTimeString()} (in ${Math.round(interval / 1000)}s) due to missing departTime`);
                return;
            }

            try {
                // Parse the departure time (format: HH:MM)
                const [hours, minutes] = departTime.split(':').map(Number);
                const now = new Date();
                const departure = new Date();
                departure.setHours(hours, minutes, 0, 0);

                // If the departure time is in the past, assume it's tomorrow
                if (departure <= now) {
                    departure.setDate(departure.getDate() + 1);
                }

                // Calculate minutes until departure
                const minutesUntilDeparture = Math.round((departure - now) / (1000 * 60));

                // Determine refresh interval based on how close the train is
                let refreshIntervalMs;

                if (minutesUntilDeparture <= 5) {
                    // Train departing within 5 minutes - refresh every 30 seconds
                    refreshIntervalMs = 30 * 1000;
                } else if (minutesUntilDeparture <= 15) {
                    // Train departing within 15 minutes - refresh every minute
                    refreshIntervalMs = 60 * 1000;
                } else if (minutesUntilDeparture <= 30) {
                    // Train departing within 30 minutes - refresh every 2 minutes
                    refreshIntervalMs = 2 * 60 * 1000;
                } else {
                    // Train departing in more than 30 minutes - refresh every 5 minutes
                    refreshIntervalMs = 5 * 60 * 1000;
                }

                refreshTimer = setTimeout(getNextTrain, refreshIntervalMs);

                // Log the exact time the next refresh is scheduled
                const scheduledAt = new Date(Date.now() + refreshIntervalMs);
                console.log(`Next refresh at ${scheduledAt.toLocaleTimeString()} (in ${Math.round(refreshIntervalMs / 1000)}s, train departs in ${minutesUntilDeparture} minutes)`);

            } catch (parseError) {
                // If we can't parse the departure time, refresh in 2 minutes
                console.warn('Could not parse departure time, using default refresh interval:', parseError);
                const interval = 2 * 60 * 1000;
                refreshTimer = setTimeout(getNextTrain, interval);
                const scheduledAt = new Date(Date.now() + interval);
                console.log(`Next refresh at ${scheduledAt.toLocaleTimeString()} (in ${Math.round(interval / 1000)}s) due to parse error`);
            }
        }

        // Clean up timer when page is unloaded
        window.addEventListener('beforeunload', function () {
            if (refreshTimer) {
                clearTimeout(refreshTimer);
            }
        });

        // Function to get current day of week in the required format
        function getCurrentDayOfWeek() {
            const now = new Date();
            return now.toLocaleDateString('en-GB', { timeZone: 'Europe/London', weekday: 'long' });
        }

        // Function to navigate to service history page
        function viewServiceHistory(dayOfWeek, scheduledTime, destination) {
            // Hide the main content and show service history
            document.querySelector('main').style.display = 'none';

            // Create service history container if it doesn't exist
            let historyContainer = document.getElementById('service-history-container');
            if (!historyContainer) {
                historyContainer = document.createElement('div');
                historyContainer.id = 'service-history-container';
                historyContainer.className = 'container';
                document.body.appendChild(historyContainer);
            }

            // Show the history container
            historyContainer.style.display = 'block';
            historyContainer.innerHTML = `
                <div class="section-header">
                    Historical Data: ${dayOfWeek} ${scheduledTime} → ${destination}
                </div>
                <div class="nav-links">
                    <a href="#" onclick="showMainPage()" class="link-large">
                        ← Back to live view
                    </a>
                </div>
                <div id="service-history-content">
                    <div>Loading historical data...</div>
                </div>
            `;

            // Load the historical data
            loadServiceHistory(dayOfWeek, scheduledTime, destination);
        }

        // Function to load service history data
        async function loadServiceHistory(dayOfWeek, scheduledTime, destination) {
            const content = document.getElementById('service-history-content');

            try {
                // Fetch service records
                const response = await fetch(`/api/service/${dayOfWeek}/${scheduledTime}/${destination}`);

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();

                if (data.records && data.records.length > 0) {
                    // Display the records in a table format
                    let tableHTML = `
                        <div class="table-container">
                            <h3 class="section-subheader">Service Records (${data.totalRecords} total)</h3>
                            <table class="table">
                                <thead>
                                    <tr>
                                        <th>Date</th>
                                        <th>Platform</th>
                                        <th>Scheduled</th>
                                        <th>Expected</th>
                                        <th>Status</th>
                                        <th>Captured</th>
                                    </tr>
                                </thead>
                                <tbody>
                    `;

                    data.records.forEach(record => {
                        const status = record.is_cancelled ? 'CANCELLED' : 'On time';
                        const platform = record.platform || 'Unknown';
                        const expectedTime = record.etd || record.std;
                        const statusClass = record.is_cancelled ? 'status-cancelled' : 'status-on-time';

                        tableHTML += `
                            <tr>
                                <td>${record.service_date}</td>
                                <td>${platform}</td>
                                <td>${record.std}</td>
                                <td>${expectedTime}</td>
                                <td class="${statusClass}">${status}</td>
                                <td>${new Date(record.created_at).toLocaleString('en-GB')}</td>
                            </tr>
                        `;
                    });

                    tableHTML += `
                                </tbody>
                            </table>
                        </div>
                    `;

                    // Also load platform distribution chart
                    tableHTML += `
                        <div class="table-container">
                            <h3 class="section-subheader">Platform Distribution</h3>
                            <div id="platform-chart-container">
                                <div>Loading platform chart...</div>
                            </div>
                        </div>
                    `;

                    content.innerHTML = tableHTML;

                    // Load platform chart
                    loadServicePlatformChart(dayOfWeek, scheduledTime, destination);

                } else {
                    content.innerHTML = `
                        <div class="message message-info">
                            No historical data found for this service.
                        </div>
                    `;
                }

            } catch (error) {
                console.error('Error loading service history:', error);
                content.innerHTML = `
                    <div class="message message-error">
                        Failed to load historical data: ${error.message}
                    </div>
                `;
            }
        }

        // Function to load platform chart for a specific service
        async function loadServicePlatformChart(dayOfWeek, scheduledTime, destination) {
            const chartContainer = document.getElementById('platform-chart-container');

            try {
                // Fetch the platform counts
                const response = await fetch(`/api/platforms/${dayOfWeek}/${scheduledTime}/${destination}`);

                if (!response.ok) {
                    throw new Error(`Chart request failed: ${response.status}`);
                }

                const data = await response.json();

                if (data.platformCounts && data.platformCounts.length > 0) {
                    // Generate a simple text-based chart
                    let chartHTML = `
                        <div class="platform-chart-container">
                            <div style="margin-bottom: 10px;">Total days observed: ${data.totalDays}</div>
                            <div class="platform-chart-grid">
                    `;

                    data.platformCounts.forEach(item => {
                        const percentage = Math.round((item.count / data.totalDays) * 100);
                        chartHTML += `
                            <div class="platform-chart-item">
                                <div class="platform-chart-item-label">Platform ${item.platform}</div>
                                <div>${item.count} days</div>
                                <div class="platform-chart-item-count">(${percentage}%)</div>
                            </div>
                        `;
                    });

                    chartHTML += `
                            </div>
                        </div>
                    `;

                    chartContainer.innerHTML = chartHTML;
                } else {
                    chartContainer.innerHTML = `
                        <div class="message-loading">
                            No platform data available for this service.
                        </div>
                    `;
                }

            } catch (error) {
                console.error('Error loading platform chart:', error);
                chartContainer.innerHTML = `
                    <div class="message-loading">
                        Unable to load platform data
                    </div>
                `;
            }
        }

        // Function to return to main page
        function showMainPage() {
            document.querySelector('main').style.display = 'block';
            const historyContainer = document.getElementById('service-history-container');
            const browserContainer = document.getElementById('service-browser-container');
            const chartContainer = document.getElementById('service-platform-chart-container');
            if (historyContainer) {
                historyContainer.style.display = 'none';
            }
            if (browserContainer) {
                browserContainer.style.display = 'none';
            }
            if (chartContainer) {
                chartContainer.style.display = 'none';
            }
        }

        // Function to show service browser
        function showServiceBrowser() {
            // Hide the main content and show service browser
            document.querySelector('main').style.display = 'none';

            // Hide other containers
            const historyContainer = document.getElementById('service-history-container');
            const chartContainer = document.getElementById('service-platform-chart-container');
            if (historyContainer) {
                historyContainer.style.display = 'none';
            }
            if (chartContainer) {
                chartContainer.style.display = 'none';
            }

            // Create service browser container if it doesn't exist
            let browserContainer = document.getElementById('service-browser-container');
            if (!browserContainer) {
                browserContainer = document.createElement('div');
                browserContainer.id = 'service-browser-container';
                browserContainer.className = 'container';
                document.body.appendChild(browserContainer);
            }

            // Show the browser container
            browserContainer.style.display = 'block';
            browserContainer.innerHTML = `
                <div class="section-header">
                    Service Browser
                </div>
                <div class="nav-links">
                    <a href="#" onclick="showMainPage()" class="link-large">
                        ← Back to live view
                    </a>
                </div>
                <div class="filter-section">
                    <input type="text" id="service-search" placeholder="Search by day, time, or destination..." 
                           class="input input-search">
                    <select id="day-filter" class="select">
                        <option value="">All Days</option>
                        <option value="Monday">Monday</option>
                        <option value="Tuesday">Tuesday</option>
                        <option value="Wednesday">Wednesday</option>
                        <option value="Thursday">Thursday</option>
                        <option value="Friday">Friday</option>
                        <option value="Saturday">Saturday</option>
                        <option value="Sunday">Sunday</option>
                    </select>
                </div>
                <div id="service-list">
                    <div>Loading services...</div>
                </div>
            `;

            // Load the services
            loadServiceList();

            // Add search functionality
            const searchInput = document.getElementById('service-search');
            const dayFilter = document.getElementById('day-filter');

            searchInput.addEventListener('input', filterServices);
            dayFilter.addEventListener('change', filterServices);
        }

        // Function to load service list
        async function loadServiceList() {
            const serviceList = document.getElementById('service-list');

            try {
                // Fetch all services
                const response = await fetch('/api/services');

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();

                if (data.services && data.services.length > 0) {
                    // Store services globally for filtering
                    window.allServices = data.services;

                    // Display the services
                    displayServices(data.services);
                } else {
                    serviceList.innerHTML = `
                        <div class="message message-info">
                            No services found in the database.
                        </div>
                    `;
                }

            } catch (error) {
                console.error('Error loading services:', error);
                serviceList.innerHTML = `
                    <div class="message message-error">
                        Failed to load services: ${error.message}
                    </div>
                `;
            }
        }

        // Function to display services
        function displayServices(services) {
            const serviceList = document.getElementById('service-list');

            // Group services by day of week
            const groupedServices = {};
            services.forEach(service => {
                if (!groupedServices[service.dayOfWeek]) {
                    groupedServices[service.dayOfWeek] = [];
                }
                groupedServices[service.dayOfWeek].push(service);
            });

            let html = `
                <div class="service-list-header">
                    Found ${services.length} services
                </div>
            `;

            // Sort days of week
            const dayOrder = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];

            dayOrder.forEach(day => {
                if (groupedServices[day]) {
                    html += `
                        <div class="service-day-group">
                            <h3 class="service-day-header">
                                ${day} (${groupedServices[day].length} services)
                            </h3>
                            <div class="service-grid">
                    `;

                    // Sort services by time
                    groupedServices[day].sort((a, b) => a.scheduledTime.localeCompare(b.scheduledTime));

                    groupedServices[day].forEach(service => {
                        html += `
                            <div class="service-card" 
                                 onclick="viewServicePlatformChart('${service.dayOfWeek}', '${service.scheduledTime}', '${service.destination}')">
                                <div class="service-card-time">${service.scheduledTime}</div>
                                <div class="service-card-destination">→ ${service.destination}</div>
                                <div class="service-card-meta">${service.totalRecords} records</div>
                                <div class="service-card-meta">First seen: ${service.firstSeen}</div>
                                <div class="service-card-link">Click to view platform chart</div>
                            </div>
                        `;
                    });

                    html += `
                            </div>
                        </div>
                    `;
                }
            });

            serviceList.innerHTML = html;
        }

        // Function to filter services
        function filterServices() {
            const searchTerm = document.getElementById('service-search').value.toLowerCase();
            const dayFilter = document.getElementById('day-filter').value;

            if (!window.allServices) return;

            let filteredServices = window.allServices;

            // Filter by day
            if (dayFilter) {
                filteredServices = filteredServices.filter(service => service.dayOfWeek === dayFilter);
            }

            // Filter by search term
            if (searchTerm) {
                filteredServices = filteredServices.filter(service =>
                    service.dayOfWeek.toLowerCase().includes(searchTerm) ||
                    service.scheduledTime.includes(searchTerm) ||
                    service.destination.toLowerCase().includes(searchTerm)
                );
            }

            displayServices(filteredServices);
        }

        // Function to view platform chart for a specific service
        function viewServicePlatformChart(dayOfWeek, scheduledTime, destination) {
            // Hide the browser and show platform chart view
            const browserContainer = document.getElementById('service-browser-container');
            if (browserContainer) {
                browserContainer.style.display = 'none';
            }

            // Create platform chart container if it doesn't exist
            let chartContainer = document.getElementById('service-platform-chart-container');
            if (!chartContainer) {
                chartContainer = document.createElement('div');
                chartContainer.id = 'service-platform-chart-container';
                chartContainer.className = 'container';
                document.body.appendChild(chartContainer);
            }

            // Show the chart container
            chartContainer.style.display = 'block';
            chartContainer.innerHTML = `
                <div class="section-header">
                    Platform Chart: ${dayOfWeek} ${scheduledTime} → ${destination}
                </div>
                <div class="nav-links">
                    <a href="#" onclick="showServiceBrowser()" class="link-large">
                        ← Back to service browser
                    </a>
                    <span class="nav-separator">|</span>
                    <a href="#" onclick="showMainPage()" class="link-large">
                        ← Back to live view
                    </a>
                </div>
                <div id="platform-chart-display">
                    <div>Loading platform chart...</div>
                </div>
            `;

            // Load the platform chart
            loadServicePlatformChartDisplay(dayOfWeek, scheduledTime, destination);
        }

        // Function to load and display platform chart
        async function loadServicePlatformChartDisplay(dayOfWeek, scheduledTime, destination) {
            const chartDisplay = document.getElementById('platform-chart-display');

            try {
                // Fetch the SVG chart from the server (same as main page)
                const response = await fetch(`/api/service-chart/${dayOfWeek}/${scheduledTime}/${destination}`);

                if (!response.ok) {
                    throw new Error(`Chart request failed: ${response.status}`);
                }

                // Get the SVG content
                const svgContent = await response.text();

                // Display the chart with animation (same as main page)
                chartDisplay.innerHTML = svgContent;

                // Add entrance animation
                chartDisplay.classList.add('chart-animate');

                // Trigger animation
                setTimeout(() => {
                    chartDisplay.classList.add('visible');
                }, 100);

            } catch (error) {
                console.error('Error loading platform chart:', error);
                chartDisplay.innerHTML = `
                    <div class="message message-error">
                        Failed to load platform chart: ${error.message}
                    </div>
                `;
            }
        }
    </script>
</body>

</html>